(function() {
  function init() {
    // Generate a random policy name to allow multiple executions.
    const randomPolicyName = 'default-' + Math.random().toString(36).substring(2);
    const policy = window.trustedTypes
      ? window.trustedTypes.createPolicy(randomPolicyName, { createHTML: (str) => str })
      : null;

    // Helper function to safely set innerHTML using TrustedHTML if available.
    function safeSetHTML(element, html) {
      element.innerHTML = policy ? policy.createHTML(html) : html;
    }

    // Create the UI container.
    const uiContainer = document.createElement('div');
    uiContainer.id = 'qaHelperUI';
    uiContainer.style.position = 'fixed';
    uiContainer.style.top = '10px';
    uiContainer.style.right = '10px';
    uiContainer.style.borderRadius = '5px';
    uiContainer.style.padding = '10px';
    uiContainer.style.zIndex = '9999';
    uiContainer.style.fontFamily = 'Arial, sans-serif';
    uiContainer.style.fontSize = '14px';
    uiContainer.style.width = '360px';

    // Initial light theme styles.
    uiContainer.style.backgroundColor = '#f0f0f0';
    uiContainer.style.border = '1px solid #ccc';
    uiContainer.style.color = '#333';

    // Create the close (X) button.
    const closeButton = document.createElement('button');
    closeButton.innerText = 'X';
    closeButton.id = 'closeButton';
    closeButton.style.position = 'absolute';
    closeButton.style.top = '5px';
    closeButton.style.right = '5px';
    closeButton.style.background = 'transparent';
    closeButton.style.border = 'none';
    closeButton.style.fontSize = '16px';
    closeButton.style.cursor = 'pointer';
    // Initial style for light mode:
    closeButton.style.color = '#333';
    closeButton.addEventListener('click', function() {
      uiContainer.remove();
    });
    uiContainer.appendChild(closeButton);

    // Create a separate container for the inner HTML so our close button isn't overwritten.
    const contentContainer = document.createElement('div');
    const innerHTMLContent = `
      <div style="margin-bottom: 8px; text-align: center;">
        <button id="toggleThemeBtn" style="padding: 5px 10px; border: none; background-color: #666; color: #fff; cursor: pointer; border-radius: 3px;">
          Toggle Dark Mode
        </button>
      </div>
      <div style="margin-bottom: 8px; font-weight: bold; font-size: 16px; text-align: center;">
        AutoForm Filler
      </div>
      <div style="margin-bottom: 8px; text-align: center;">
        <input id="questionNumber" type="number" placeholder="Question #" style="width: 60px; margin-right: 10px;">
        <button id="showOptionsBtn" style="padding: 5px 10px; border: none; background-color: #2196F3; color: #fff; cursor: pointer; border-radius: 3px; margin-right: 5px;">
          Show Options
        </button>
        <button id="determineAnswerBtn" style="padding: 5px 10px; border: none; background-color: #4CAF50; color: #fff; cursor: pointer; border-radius: 3px;">
          Determine Final Answer
        </button>
      </div>
      <div style="margin-bottom: 8px;">
        <strong>Possible Answers:</strong>
        <div id="possibleAnswers" style="background-color: #fff; padding: 5px; border: 1px solid #ccc; border-radius: 3px; margin-top: 5px; max-height: 100px; overflow-y: auto; color: #333;">
          None yet
        </div>
      </div>
      <div style="margin-bottom: 8px;">
        <strong>Final Answer:</strong>
        <div id="finalAnswer" style="background-color: #fff; padding: 5px; border: 1px solid #ccc; border-radius: 3px; margin-top: 5px; text-align: center; color: #333;">
          None yet
        </div>
      </div>
      <div style="background-color: #222; padding: 5px; border-radius: 3px; color: #fff;">
        <div style="font-weight: bold; text-align: center; margin-bottom: 5px;">Logs</div>
        <!-- Now the log container has its own scrolling -->
        <div id="statusLog" style="font-size: 12px; line-height: 1.4em; max-height: 150px; overflow-y: auto;"></div>
      </div>
    `;
    safeSetHTML(contentContainer, innerHTMLContent);
    uiContainer.appendChild(contentContainer);

    document.body.appendChild(uiContainer);

    // Current theme state ("light" or "dark").
    let currentTheme = 'light';

    // Function to update UI styles based on the theme.
    function setTheme(theme) {
      const toggleThemeBtn = document.getElementById('toggleThemeBtn');
      const showOptionsBtn = document.getElementById('showOptionsBtn');
      const determineAnswerBtn = document.getElementById('determineAnswerBtn');
      const possibleAnswersDiv = document.getElementById('possibleAnswers');
      const finalAnswerDiv = document.getElementById('finalAnswer');

      if (theme === 'dark') {
        uiContainer.style.backgroundColor = '#222';
        uiContainer.style.border = '1px solid #444';
        uiContainer.style.color = '#eee';

        showOptionsBtn.style.backgroundColor = '#555';
        showOptionsBtn.style.color = '#fff';
        determineAnswerBtn.style.backgroundColor = '#5cb85c';
        determineAnswerBtn.style.color = '#fff';
        toggleThemeBtn.style.backgroundColor = '#555';
        toggleThemeBtn.style.color = '#fff';

        possibleAnswersDiv.style.backgroundColor = '#333';
        possibleAnswersDiv.style.border = '1px solid #555';
        possibleAnswersDiv.style.color = '#eee';
        finalAnswerDiv.style.backgroundColor = '#333';
        finalAnswerDiv.style.border = '1px solid #555';
        finalAnswerDiv.style.color = '#eee';

        toggleThemeBtn.innerText = "Toggle Light Mode";
        // Update close button for dark mode.
        closeButton.style.color = '#eee';
      } else {
        uiContainer.style.backgroundColor = '#f0f0f0';
        uiContainer.style.border = '1px solid #ccc';
        uiContainer.style.color = '#333';

        showOptionsBtn.style.backgroundColor = '#2196F3';
        showOptionsBtn.style.color = '#fff';
        determineAnswerBtn.style.backgroundColor = '#4CAF50';
        determineAnswerBtn.style.color = '#fff';
        toggleThemeBtn.style.backgroundColor = '#666';
        toggleThemeBtn.style.color = '#fff';

        possibleAnswersDiv.style.backgroundColor = '#fff';
        possibleAnswersDiv.style.border = '1px solid #ccc';
        possibleAnswersDiv.style.color = '#333';
        finalAnswerDiv.style.backgroundColor = '#fff';
        finalAnswerDiv.style.border = '1px solid #ccc';
        finalAnswerDiv.style.color = '#333';

        toggleThemeBtn.innerText = "Toggle Dark Mode";
        // Update close button for light mode.
        closeButton.style.color = '#333';
      }
    }

    // Toggle theme event listener.
    document.getElementById('toggleThemeBtn').addEventListener('click', function() {
      currentTheme = currentTheme === 'light' ? 'dark' : 'light';
      setTheme(currentTheme);
    });

    // === Logging Helper ===
    function logStatus(message) {
      const logDiv = document.getElementById('statusLog');
      if (logDiv) {
        const p = document.createElement('p');
        p.style.margin = '2px 0';
        p.textContent = message;
        logDiv.appendChild(p);
        // Auto-scroll: set scrollTop to scrollHeight so that the new message is visible.
        logDiv.scrollTop = logDiv.scrollHeight;
      }
      console.log(message);
    }

    // === Sleep Helper ===
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // === Global Variables for Current Question Data ===
    let currentQuestionText = '';
    let currentOptions = []; // Array of objects: { text, element, score, letter }

    // === Gather All Question Containers ===
    const containerSelectors = [
      'div.freebirdFormviewerComponentsQuestionBaseRoot',
      'div.freebirdFormviewerComponentsQuestionItem',
      'div[role="listitem"]'
    ];
    let questionContainers = [];
    containerSelectors.forEach(selector => {
      const found = Array.from(document.querySelectorAll(selector));
      if (found.length > 0) {
        logStatus(`Found ${found.length} container(s) with selector: "${selector}"`);
      }
      questionContainers = questionContainers.concat(found);
    });
    // Remove duplicates.
    questionContainers = Array.from(new Set(questionContainers));
    logStatus(`Total unique question containers: ${questionContainers.length}`);

    // === Function: Show Options (Step 1) ===
    function showOptions(container) {
      // Clear previous displays.
      safeSetHTML(document.getElementById('possibleAnswers'), '');
      document.getElementById('finalAnswer').innerText = '';
      currentQuestionText = '';
      currentOptions = [];

      // Extract question text.
      const titleSelectors = [
        '.freebirdFormviewerComponentsQuestionBaseTitle',
        '.freebirdFormviewerComponentsQuestionItemTitle',
        'div[role="heading"]'
      ];
      for (const sel of titleSelectors) {
        const qEl = container.querySelector(sel);
        if (qEl && qEl.innerText.trim() !== '') {
          currentQuestionText = qEl.innerText.trim();
          break;
        }
      }
      if (!currentQuestionText) {
        currentQuestionText = container.textContent.trim();
        logStatus('Question text not found using title selectors; using container text as fallback.');
      }
      if (!currentQuestionText) {
        logStatus('No question text available even with fallback.');
        return;
      }
      logStatus(`Question: "${currentQuestionText}"`);

      // Attempt primary method: Use common selectors for options.
      let optionsElements = [];
      optionsElements = optionsElements.concat(Array.from(container.querySelectorAll('div.freebirdFormviewerComponentsQuestionOptionItem')));
      optionsElements = optionsElements.concat(Array.from(container.querySelectorAll('.exportLabel')));
      optionsElements = optionsElements.concat(Array.from(container.querySelectorAll('div[role="radio"], div[role="checkbox"]')));
      // New selector: grab answer labels (common in Google Forms).
      optionsElements = optionsElements.concat(Array.from(container.querySelectorAll('label.docssharedWizToggleLabeledContainer')));

      // If still no options, try radio/checkbox inputs.
      if (optionsElements.length === 0) {
        const optionInputs = container.querySelectorAll('input[type="radio"], input[type="checkbox"]');
        optionInputs.forEach(input => {
          const label = input.closest('label');
          if (label) {
            optionsElements.push(label);
          }
        });
        logStatus(`Fallback: Found ${optionInputs.length} input(s) for possible answers.`);
      } else {
        logStatus(`Primary: Found ${optionsElements.length} candidate option element(s).`);
      }

      // Extract unique option texts.
      const seenTexts = new Set();
      optionsElements.forEach(el => {
        let text = el.innerText.trim();
        if (text && text.replace(/[\W_]/g, '').length > 0 && !seenTexts.has(text)) {
          seenTexts.add(text);
          currentOptions.push({ text: text, element: el, score: 0 });
        }
      });

      if (currentOptions.length === 0) {
        logStatus('No multiple-choice options found.');
        logStatus('Question container HTML: ' + container.innerHTML);
        return;
      }

      // Map options to letters.
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let possibleHTML = '<ul style="list-style: none; padding: 0; margin: 0;">';
      currentOptions.forEach((opt, idx) => {
        let letter = letters[idx] || '?';
        opt.letter = letter;
        possibleHTML += `<li style="margin-bottom: 4px;">${letter}: ${opt.text}</li>`;
      });
      possibleHTML += '</ul>';
      safeSetHTML(document.getElementById('possibleAnswers'), possibleHTML);
      logStatus('Displayed candidate options with letter mappings.');
    }

    // === Function: Determine Final Answer (Step 2) ===
    async function determineFinalAnswer() {
      if (!currentQuestionText || currentOptions.length === 0) {
        logStatus('No current question or options. Please use "Show Options" first.');
        return;
      }

      // For each candidate option, perform a query and analyze snippet texts.
      for (const candidate of currentOptions) {
        const combinedQuery = `${currentQuestionText} ${candidate.text}`;
        const sanitizedCombinedQuery = combinedQuery.replace(/[\r\n]+/g, ' ').replace(/\*+/g, '').trim();
        const encodedQuery = encodeURIComponent(sanitizedCombinedQuery);
        const apiKey = 'AIzaSyC4HWhlAgRiEN1zg6zbTDuVNpsrvgh-8_A';
        const cx = '176033061b13f4141';
        const searchUrl = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${cx}&q=${encodedQuery}&num=3`;
        logStatus(`Querying for option "${candidate.text}" using query: ${sanitizedCombinedQuery}`);
        try {
          const response = await fetch(searchUrl);
          if (!response.ok) {
            logStatus(`Error for option "${candidate.text}": Received status ${response.status}`);
            candidate.score = 0;
            continue;
          }
          const data = await response.json();
          let snippetScore = 0;
          if (data.items && data.items.length > 0) {
            data.items.forEach(item => {
              const snippet = item.snippet || "";
              const regex = new RegExp(candidate.text, "gi");
              const matches = snippet.match(regex);
              if (matches) {
                snippetScore += matches.length;
              }
            });
          }
          candidate.score = snippetScore;
          logStatus(`Option "${candidate.text}" got a snippet score of ${snippetScore}.`);
        } catch (err) {
          logStatus(`Error for option "${candidate.text}": ${err.message}`);
          candidate.score = 0;
        }
        await sleep(1000);
      }

      // Display updated candidate options with snippet scores.
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let possibleHTML = '<ul style="list-style: none; padding: 0; margin: 0;">';
      currentOptions.forEach(opt => {
        possibleHTML += `<li style="margin-bottom: 4px;">${opt.letter}: ${opt.text} (score: ${opt.score})</li>`;
      });
      possibleHTML += '</ul>';
      safeSetHTML(document.getElementById('possibleAnswers'), possibleHTML);
      logStatus('Updated candidate options with snippet scores.');

      // Determine the best candidate based on the highest score.
      let bestCandidate = currentOptions.reduce((prev, curr) => (curr.score > prev.score ? curr : prev), { score: 0 });
      if (bestCandidate && bestCandidate.score > 0 && bestCandidate.text) {
        document.getElementById('finalAnswer').innerText = bestCandidate.letter;
        logStatus(`Final answer: ${bestCandidate.letter} (option "${bestCandidate.text}" with score ${bestCandidate.score}).`);
      } else {
        logStatus('No candidate returned a positive score.');
        document.getElementById('finalAnswer').innerText = 'No valid answer found';
      }
    }

    // === Button Event Listeners ===
    document.getElementById('showOptionsBtn').addEventListener('click', function() {
      const qNumInput = document.getElementById('questionNumber').value;
      const qIndex = parseInt(qNumInput, 10) - 1;
      if (isNaN(qIndex) || qIndex < 0 || qIndex >= questionContainers.length) {
        logStatus(`Invalid question number. Enter a number between 1 and ${questionContainers.length}.`);
        return;
      }
      logStatus(`Showing options for question ${qIndex + 1} of ${questionContainers.length}`);
      showOptions(questionContainers[qIndex]);
    });

    document.getElementById('determineAnswerBtn').addEventListener('click', async function() {
      logStatus('Determining final answer based on candidate snippet analysis...');
      await determineFinalAnswer();
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();

